//! Catibo provides support for the CTB family of formats, used by popular
//! low-end resin 3D printers.
//!
//! # Common elements
//!
//! The family of file formats handled here are related by a common file header
//! layout and overall structure.
//!
//! - Multi-byte values, such as `u32` and `f32`, are encoded in little-endian
//! unless otherwise stated, and are *not* aligned in any particular way.
//!
//! - Many parameters in the file are represented in floating point,
//! specifically single-precision IEEE754 floating point.
//!
//! - References within the file are stored as a byte offset from the start of
//! the file, encoded as a `u32`, giving a maximum practical file size of just
//! under 4GiB. Some sections of the file are referenced using both an offset
//! and length, allowing them to change in size.
//!
//! - All formats contain stretches of unused bytes that appear to be reserved
//! for future expansion. Files generated by the C++ proprietary software
//! occasionally emit recognizable return addresses and other stack data into
//! these areas, suggesting that they were written from uninitialized memory;
//! this implementation ignores them on input and zeroes them on output.
//!
//! - Each file begins with a *magic number*, a 4-byte value identifying the
//! variant of the file format, and a *version*, a `u32` that could distinguish
//! revisions of the format, but in practice is constant.
//!
//! - The first chunk of the file is a *file header*, a fixed-size record that
//! describes the layout of the rest of the file, along with some of the machine
//! settings. Nothing else in the file is at a fixed location -- every location
//! is derived from this header.
//!
//! - There are two *preview images* referenced from the file header, used to
//! display a thumbnail of the model in the file browser and confirmation screen
//! on the printer. These images are encoded in a simple embedded-friendly
//! format with limited color depth.
//!
//! - There is a *layer table*, containing fixed size records, one per
//! layer/slice of the model. Each record gives some information about the
//! slice, and contains a further reference to where the encoded slice data is
//! stored in the file.
//!
//! - Encoded layers are represented using simple RLE compression schemes (three
//! have been observed in the wild), with optional encryption.
//!
//! # Format variations
//!
//! See the `doc/` folder in the source repository for detailed discussion of
//! format differences.

#![warn(
    bare_trait_objects,
    missing_docs,
    trivial_casts,
    trivial_numeric_casts,
    unreachable_pub,
    unsafe_code,
    unused_qualifications
)]

pub mod crypto;
pub mod input;
pub mod output;
pub mod rle;

use byteorder::LittleEndian;
use num_derive::{FromPrimitive, ToPrimitive};
use zerocopy::{AsBytes, FromBytes, Unaligned};

/// Enumeration of known magic number values. Also punned as a way of indicating
/// file formats, since that's what magic numbers are for.
#[derive(Copy, Clone, Debug, PartialEq, Eq, FromPrimitive, ToPrimitive)]
#[repr(u32)]
pub enum Magic {
    /// The older 1-bit planar format.
    CBDDLP = 0x12fd_0019,
    /// The newer 7-bit chunky encrypted format.
    CTB = 0x12fd_0086,
    /// The newer-er other 7-bit chunky encrypted format.
    PHZ = 0x9fda_83ae,
}

impl Magic {
    /// Checks whether a given version number is recognized for files with this
    /// magic number.
    pub fn is_version_ok(self, version: u32) -> bool {
        // Currently, every file observed in the wild uses version 2.
        version == 2
    }

    /// Checks whether files with this magic number are expected to use
    /// level-based AA representation, where slices are multiplied.
    pub fn uses_aa_levels(self) -> bool {
        match self {
            Self::CTB => false,
            Self::CBDDLP | Self::PHZ => true,
        }
    }

    /// Which header style does a file with this magic use?
    pub fn header_style(self) -> HeaderStyle {
        match self {
            Magic::PHZ => HeaderStyle::Omni,
            _ => HeaderStyle::Split,
        }
    }

    /// Produces variant names for Clap compatibility, without requiring Clap in
    /// the library.
    pub fn variants() -> &'static [&'static str] {
        &["cbddlp", "ctb", "phz"]
    }

    /// Which encryption method, if any, do files with this magic use?
    pub fn encryption(self) -> Option<Cipher> {
        match self {
            Self::CTB => Some(Cipher::_86),
            Self::PHZ => Some(Cipher::_9f),
            _ => None,
        }
    }
}

/// Parses file extensions to magic numbers.
impl std::str::FromStr for Magic {
    type Err = BadMagicNameError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s.eq_ignore_ascii_case("cbddlp") {
            return Ok(Self::CBDDLP);
        } else if s.eq_ignore_ascii_case("ctb") {
            return Ok(Self::CTB);
        } else if s.eq_ignore_ascii_case("phz") {
            return Ok(Self::PHZ);
        } else {
            return Err(BadMagicNameError);
        }
    }
}

/// Error used to signal an invalid conversion from a `str` to `Magic`.
#[derive(Copy, Clone, Debug)]
pub struct BadMagicNameError;

impl std::fmt::Display for BadMagicNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.write_str("unrecognized file format")
    }
}

/// Distinguishes styles of header when the magic is asked.
#[derive(Copy, Clone, Debug)]
pub enum HeaderStyle {
    /// File uses split header style.
    Split,
    /// File uses unified omniheader.
    Omni,
}

/// Names different ciphers when the magic is asked.
#[derive(Copy, Clone, Debug)]
pub enum Cipher {
    /// The "86 cipher" observed in ctb files.
    _86,
    /// The "9f cipher" observed in phz files.
    _9f,
}

/// Shorthand for little-endian `u32`s.
pub type U32LE = zerocopy::byteorder::U32<LittleEndian>;
/// Shorthand for little-endian `u16`s.
pub type U16LE = zerocopy::byteorder::U16<LittleEndian>;

/// A little-endian `f32`, not necessarily aligned.
#[derive(Copy, Clone, Default, AsBytes, FromBytes, Unaligned)]
#[repr(transparent)]
pub struct F32LE(U32LE);

impl F32LE {
    /// Encodes an `f32` in little-endian.
    ///
    /// Note that chances are very good this is a no-op, since the computer
    /// you're using is likely to be natively little-endian.
    pub fn new(val: f32) -> Self {
        F32LE(U32LE::new(val.to_bits()))
    }

    /// Decodes the `f32` from little-endian.
    pub fn get(self) -> f32 {
        f32::from_bits(self.0.get())
    }
}

impl core::fmt::Debug for F32LE {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        self.get().fmt(f)
    }
}

/// Common file header layout. This comes at the start of the file and tells us
/// what to look for next.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct MagicHeader {
    /// Magic number that determines the file encoding, etc. Values we currently
    /// understand are listed in the `Magic` enum.
    pub magic: U32LE,
    /// File format version number. In practice, always 2.
    pub version: U32LE,
}

/// Split file header layout.
///
/// This header record is split over three physical records: this one,
/// `ExtConfig`, and `ExtConfig2`. It preferences the other two by offset and
/// size. (This appears to be for historical reasons.)
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct SplitHeader {
    /// Printer output volume in millimeters along X, Y, Z.
    pub printer_out_mm: [F32LE; 3],

    /// Unknown sequence of 8 bytes, always contains zeros in the wild.
    pub _unknown_14: [u8; 8],
    /// Overall height of model in mm.
    pub overall_height_mm: F32LE,

    /// File-wide layer height setting. This reflects the setting used in the
    /// slicer and is not used during printing; in practice, actual layer height
    /// is given for each layer in the layer table, and can vary.
    pub layer_height_mm: F32LE,

    /// File-wide normal layer exposure setting. This reflects the setting used
    /// in the slicer and is not used during printing; in practice, actual
    /// exposure is given for each layer in the layer table, and can vary.
    pub exposure_s: F32LE,

    /// File-wide "bottom" layer exposure setting. This reflects the setting
    /// used in the slicer and is not used during printing; in practice, actual
    /// exposure is given for each layer in the layer table, and can vary.
    pub bot_exposure_s: F32LE,

    /// File-wide off-time setting. This reflects the setting used in the
    /// slicer and is not used during printing; in practice, actual off-time is
    /// given for each layer in the layer table, and can vary.
    pub light_off_time_s: F32LE,

    /// Number of layers considered to be "bottom". This reflects the setting
    /// used in the slicer and is not used during printing.
    pub bot_layer_count: U32LE,

    /// Printer resolution along X, Y axes.
    pub resolution: [U32LE; 2],

    /// File offset of the large preview image's `ImageHeader`.
    pub large_preview_offset: U32LE,

    /// File offset of the first `LayerHeader`.
    pub layer_table_offset: U32LE,
    /// Number of `LayerHeader`s in the layer table.
    pub layer_table_count: U32LE,

    /// File offset of the small preview image's `ImageHeader`.
    pub small_preview_offset: U32LE,

    /// Estimated print time, in seconds.
    pub print_time_s: U32LE,

    /// Normal (0) or `LCD_mirror` (1) transform required for printer. This
    /// doesn't appear to actually control any printer behavior.
    pub mirror: U32LE,

    /// File offset of the `ExtConfig` record.
    pub ext_config_offset: U32LE,
    /// Length of the `ExtConfig` record in bytes. In practice, this is always
    /// `0x3C`, and our `ExtConfig` struct is sized to reflect this -- but it
    /// appears to be padded for expansion and the final bytes are unused.
    pub ext_config_size: U32LE,

    /// Level set count. This records the number of copies of each layer that
    /// are present. For 1bpp representations, this is equivalent to the
    /// antialiasing level (because those formats implement antialiasing by
    /// repetition). For 7bpp representations, this appears to be ignored,
    /// and should be set to `1` for consistency.
    pub level_set_count: U32LE,

    /// UV LED PWM level for normal layers. While stored in a 16-bit field this
    /// appears to be an 8-bit value. Larger numbers mean higher duty cycle.
    pub pwm_level: U16LE,
    /// UV LED PWM level for bottom layers.
    pub bot_pwm_level: U16LE,

    /// Encryption key. Zero means unencrypted. File formats that don't normally
    /// use encryption should zero this.
    pub encryption_key: U32LE,

    /// File offset of the `ExtConfig2` record.
    pub ext_config2_offset: U32LE,
    /// Length of the `ExtConfig2` record, in bytes. In practice, this is always
    /// `0x4C`, and our `ExtConfig2` struct is sized to reflect this -- but it
    /// appears to be padded for expansion and the final bytes are unused.
    pub ext_config2_size: U32LE,
}

/// Configuration extension record. This includes some print settings that are
/// not part of the file header.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct ExtConfig {
    /// Bed lift distance during bottom layers, in millimeters.
    pub bot_lift_dist_mm: F32LE,
    /// Bed lift speed during bottom layers, in millimeters per minute.
    pub bot_lift_speed_mmpm: F32LE,
    /// Bed lift distance during normal layers, in millimeters.
    pub lift_dist_mm: F32LE,
    /// Bed lift speed during normal layers, in millimeters per minute.
    pub lift_speed_mmpm: F32LE,
    /// Retract speed, in millimeters per minute. This is the speed at which the
    /// bed re-approaches the screen after lifting.
    pub retract_speed_mmpm: F32LE,
    /// Estimated volume of resin required for print, in milliliters.
    pub print_volume_ml: F32LE,
    /// Estimated weight of resin required for print, in grams. This is derived
    /// from the volume estimate according to the configured resin density.
    pub print_mass_g: F32LE,
    /// Estimated cost of resin required for print, in user's local currency.
    /// (Currency unit does not appear to be stored in the file, and changing it
    /// does not affect the estimate.)
    pub print_price: F32LE,
    /// Bottom-layer light off-time, in seconds. This determines how long the
    /// light is off between bottom layers.
    pub bot_light_off_time_s: F32LE,
    /// Normal-layer light off-time, in seconds. This determines how long the
    /// light is off between non-bottom layers. Apparent duplicate of
    /// `SplitHeader::light_off_time_s`, always matches in the wild.
    pub light_off_time_s: F32LE,
    /// Number of layers considered to be "bottom." Apparent duplicate of
    /// `SplitHeader::bot_layer_count`, always matches in the wild.
    pub bot_layer_count: U32LE,

    /// 16 bytes apparently reserved for expansion
    pub _unknown_2c: [u8; 16],
}

/// Configuration extension record, volume two. This includes more print
/// settings that are not part of the file header.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct ExtConfig2 {
    /// Unknown run of 28 bytes, always zero in practice.
    pub _unknown_0: [u8; 28],
    /// File offset of printer type name. This is the software's internal name
    /// for the printer type, *not* the user-assigned profile name.
    ///
    /// Note: while I've only observed ASCII in the machine type name, I
    /// strongly suspect it to be using UTF-8.
    pub machine_type_offset: U32LE,
    /// Number of bytes in printer type name.
    pub machine_type_len: U32LE,
    /// Controls the encryption parameters. This field is not completely
    /// understood. Zero for unencrypted files.
    ///
    /// Observed values:
    /// - `ctb`: `0xF`
    /// - `phz`: `0x1c` (though not using this header format)
    pub encryption_mode: U32LE,

    /// This mysterious number increments with some combination of time and
    /// slicing.
    pub mysterious_id: U32LE,

    /// User antialiasing setting.
    ///
    /// For 1bpp formats, this will match the `level_set_count` from the file
    /// header. For deeper formats (7bpp) this indicates whether thresholding
    /// was performed on the image data.
    pub antialias_level: U32LE,

    /// Software revision, stored as 0xmajor_minor_patch_00.
    pub software_version: U32LE,

    /// Observed as 0x200
    pub _unknown_34: U32LE,

    /// 20 bytes apparently reserved for future expansion.
    pub _unknown_38: [u8; 20],
}

/// Record used to describe the preview images.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct ImageHeader {
    /// Size along X, Y, in pixels.
    pub size: [U32LE; 2],
    /// File offset of encoded image data.
    pub data_offset: U32LE,
    /// Length of encoded image data, in bytes.
    pub data_len: U32LE,

    /// Unknown 16-byte run. Always zero in proprietary output, probably
    /// reserved for expansion.
    pub _unknown_10: [u8; 16],
}

/// Record that describes a single layer/slice of the model.
///
/// Files contain a contiguous table of these, referenced from the file header.
/// These in turn reference each layer's data.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct LayerHeader {
    /// Position of the build platform for this layer, in millimeters.
    pub z: F32LE,
    /// Exposure time for this layer, in seconds.
    pub exposure_s: F32LE,
    /// Time the light should be kept off after this layer, in seconds.
    pub light_off_time_s: F32LE,
    /// File offset of this layer's encoded data.
    pub data_offset: U32LE,
    /// Length of this layer's encoded data, in bytes.
    pub data_len: U32LE,

    /// Unknown run of 16 bytes, always zeroed in practice.
    pub _unknown_14: [u8; 16],
}

/// A unified file header that combines the role of `SplitHeader`, `ExtConfig`,
/// and `ExtConfig2`, introduced circa 2020 in `phz` files.
///
/// This has field ordering and role that strongly suggests someone started with
/// the header files for the old header and moved lines around. The field names
/// match those in the other header records where their roles appear to be
/// equivalent.
///
/// The format of all referenced records (`ImageHeader`, `LayerHeader`) does not
/// appear to have changed.
#[derive(Clone, Debug, Default, AsBytes, FromBytes, Unaligned)]
#[repr(C)]
pub struct OmniHeader {
    /// File-wide layer height setting. This reflects the setting used in the
    /// slicer and is not used during printing; in practice, actual layer height
    /// is given for each layer in the layer table, and can vary.
    pub layer_height_mm: F32LE,
    /// File-wide normal layer exposure setting. This reflects the setting used
    /// in the slicer and is not used during printing; in practice, actual
    /// exposure is given for each layer in the layer table, and can vary.
    pub exposure_s: F32LE,
    /// File-wide "bottom" layer exposure setting. This reflects the setting
    /// used in the slicer and is not used during printing; in practice, actual
    /// exposure is given for each layer in the layer table, and can vary.
    pub bot_exposure_s: F32LE,
    /// Number of layers considered to be "bottom". This reflects the setting
    /// used in the slicer and is not used during printing.
    pub bot_layer_count: U32LE,
    /// Printer resolution along X, Y axes.
    pub resolution: [U32LE; 2],
    /// File offset of the large preview image's `ImageHeader`.
    pub large_preview_offset: U32LE,
    /// File offset of the first `LayerHeader`.
    pub layer_table_offset: U32LE,
    /// Number of `LayerHeader`s in the layer table.
    pub layer_table_count: U32LE,
    /// File offset of the small preview image's `ImageHeader`.
    pub small_preview_offset: U32LE,
    /// Estimated print time, in seconds.
    pub print_time_s: U32LE,
    /// Normal (0) or `LCD_mirror` (1) transform required for printer. This
    /// doesn't appear to actually control any printer behavior.
    pub mirror: U32LE,
    /// Level set count. This records the number of copies of each layer that
    /// are present. For 1bpp representations, this is equivalent to the
    /// antialiasing level (because those formats implement antialiasing by
    /// repetition). For 7bpp representations, this appears to be ignored,
    /// and should be set to `1` for consistency.
    pub level_set_count: U32LE,
    /// UV LED PWM level for normal layers. While stored in a 16-bit field this
    /// appears to be an 8-bit value. Larger numbers mean higher duty cycle.
    pub pwm_level: U16LE,
    /// UV LED PWM level for bottom layers.
    pub bot_pwm_level: U16LE,

    /// Consistently zeroed.
    pub _zero_40: [u8; 8],

    /// Overall height of model in mm.
    pub overall_height_mm: F32LE,
    /// Printer output volume in millimeters along X, Y, Z.
    pub printer_out_mm: [F32LE; 3],
    /// Encryption key. Zero means unencrypted.
    pub encryption_key: U32LE,
    /// Bottom-layer light off-time, in seconds. This determines how long the
    /// light is off between bottom layers.
    pub bot_light_off_time_s: F32LE,
    /// File-wide off-time setting. This reflects the setting used in the
    /// slicer and is not used during printing; in practice, actual off-time is
    /// given for each layer in the layer table, and can vary.
    pub light_off_time_s: F32LE, // or vice versa, check
    /// Apparent reptition of the bottom layer count.
    pub bot_layer_count_again: U32LE,

    /// Consistently zeroed.
    pub _zero_68: [u8; 4],

    /// Bed lift distance during bottom layers, in millimeters.
    pub bot_lift_dist_mm: F32LE,
    /// Bed lift speed during bottom layers, in millimeters per minute.
    pub bot_lift_speed_mmpm: F32LE,
    /// Bed lift distance during normal layers, in millimeters.
    pub lift_dist_mm: F32LE,
    /// Bed lift speed during normal layers, in millimeters per minute.
    pub lift_speed_mmpm: F32LE,
    /// Retract speed, in millimeters per minute. This is the speed at which the
    /// bed re-approaches the screen after lifting.
    pub retract_speed_mmpm: F32LE,
    /// Estimated volume of resin required for print, in milliliters.
    pub print_volume_ml: F32LE,
    /// Estimated weight of resin required for print, in grams. This is derived
    /// from the volume estimate according to the configured resin density.
    pub print_mass_g: F32LE,
    /// Estimated cost of resin required for print, in user's local currency.
    /// (Currency unit does not appear to be stored in the file, and changing it
    /// does not affect the estimate.)
    pub print_price: F32LE,

    /// Consistently zeroed.
    pub _zero_8c: [u8; 4],

    /// File offset of printer type name. This is the software's internal name
    /// for the printer type, *not* the user-assigned profile name.
    ///
    /// Note: while I've only observed ASCII in the machine type name, I
    /// strongly suspect it to be using UTF-8.
    pub machine_type_offset: U32LE,
    /// Number of bytes in printer type name.
    pub machine_type_len: U32LE,

    /// Consistently zeroed.
    pub _zero_98: [u8; 6 * 4],

    /// Controls the encryption parameters. This field is not completely
    /// understood. Zero for unencrypted files.
    ///
    /// Observed values:
    /// - `ctb`: `0xF`
    /// - `phz`: `0x1c` (though not using this header format)
    pub encryption_mode: U32LE,
    /// This mysterious number increments with some combination of time and
    /// slicing.
    pub mysterious_id: U32LE,
    /// User antialiasing setting.
    ///
    /// This indicates whether thresholding was performed on the image data.
    pub antialias_level: U32LE,
    /// Software revision, stored as 0xmajor_minor_patch_00.
    pub software_version: U32LE,

    /// Consistently zeroed.
    pub _zero_c0: [u8; 4 * 6],
}
